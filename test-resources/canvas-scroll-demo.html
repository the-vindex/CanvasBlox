<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scrollable Canvas Editor - Proof of Concept</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden; /* Prevent body scrolling */
      height: 100vh;
    }

    /* Main app container - uses CSS Grid for layout */
    .app-container {
      display: grid;
      grid-template-rows: auto 1fr; /* Header takes content height, main area fills rest */
      grid-template-columns: 1fr auto; /* Main area fills, sidebar takes content width */
      height: 100vh;
    }

    /* Fixed header spans full width */
    .header {
      grid-column: 1 / -1;
      background: #1a1a1a;
      color: white;
      padding: 1rem;
      border-bottom: 1px solid #333;
    }

    /* Main scrollable canvas area */
    .canvas-container {
      grid-column: 1;
      grid-row: 2;
      /* KEY: This creates the scrollable area with VISIBLE scrollbars */
      overflow: auto; /* Shows scrollbars when content is larger than container */
      background: #2a2a2a; /* Background shows when canvas is smaller */
      position: relative;
    }

    /* Canvas wrapper - sizes to canvas dimensions */
    .canvas-wrapper {
      /*
        KEY: This wrapper is sized to the canvas dimensions.
        It creates the scrollable content area that's larger than the viewport.
        Position relative so absolutely positioned overlays use this as reference.
      */
      position: relative;
      width: 1920px;
      height: 960px;
      /* Center the canvas in the scrollable area when viewport is larger */
      margin: 0 auto;
    }

    /* The actual canvas element */
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #f0f0f0;
      cursor: crosshair;
    }

    /*
      Absolutely positioned overlay - demonstrates how UI elements
      can be positioned on top of the canvas and move with it during scrolling.
      Uses the canvas-wrapper as the positioning context.
    */
    .canvas-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem;
      border-radius: 4px;
      pointer-events: none; /* Allows clicking through to canvas */
      font-size: 14px;
      max-width: 300px;
    }

    /* Scanline effect overlay - demonstrates visual effects */
    .scanline-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.03) 2px,
        rgba(0, 0, 0, 0.03) 4px
      );
      pointer-events: none;
    }

    /* Fixed sidebar - independent of canvas scrolling */
    .sidebar {
      grid-column: 2;
      grid-row: 2;
      width: 300px;
      background: #1a1a1a;
      color: white;
      padding: 1rem;
      border-left: 1px solid #333;
      overflow-y: auto; /* Sidebar has its own scroll if content is tall */
    }

    .sidebar h3 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #333;
    }

    .property-item {
      margin-bottom: 1rem;
    }

    .property-label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 12px;
      color: #999;
    }

    .property-value {
      background: #2a2a2a;
      border: 1px solid #333;
      color: white;
      padding: 0.5rem;
      width: 100%;
      border-radius: 3px;
    }

    /* Visual feedback for scrollbars */
    .canvas-container::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    .canvas-container::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    .canvas-container::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 6px;
    }

    .canvas-container::-webkit-scrollbar-thumb:hover {
      background: #777;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Fixed Header -->
    <header class="header">
      <h1>Scrollable Canvas Editor - Proof of Concept</h1>
    </header>

    <!-- Main Scrollable Canvas Area -->
    <main class="canvas-container">
      <!--
        Canvas wrapper creates the scrollable content area.
        Its dimensions (1920x960) exceed typical viewport size,
        triggering scrollbars in the parent container.
      -->
      <div class="canvas-wrapper">
        <!-- The actual canvas element -->
        <canvas id="canvas" width="1920" height="960"></canvas>

        <!-- Absolutely positioned overlay - moves with canvas during scroll -->
        <div class="canvas-overlay">
          <strong>Canvas Info</strong><br>
          Size: 1920 x 960 px<br>
          Scroll the canvas using:<br>
          - Two-finger touchpad drag<br>
          - Mouse wheel / trackpad scroll<br>
          - Click and drag scrollbar<br><br>
          This overlay scrolls with the canvas.
        </div>

        <!-- Visual effect overlay -->
        <div class="scanline-overlay"></div>
      </div>
    </main>

    <!-- Fixed Sidebar -->
    <aside class="sidebar">
      <h3>Properties Panel</h3>
      <div class="property-item">
        <label class="property-label">Canvas Width</label>
        <input type="text" class="property-value" value="1920" readonly>
      </div>
      <div class="property-item">
        <label class="property-label">Canvas Height</label>
        <input type="text" class="property-value" value="960" readonly>
      </div>
      <div class="property-item">
        <label class="property-label">Scroll Position</label>
        <input type="text" class="property-value" id="scroll-pos" value="0, 0" readonly>
      </div>
      <div class="property-item">
        <label class="property-label">Mouse Position</label>
        <input type="text" class="property-value" id="mouse-pos" value="-" readonly>
      </div>
      <div class="property-item">
        <label class="property-label">Notes</label>
        <textarea class="property-value" rows="6" readonly>This sidebar is fixed and does not scroll with the canvas. It maintains its position independently.

The canvas area uses native browser scrolling with visible scrollbars.</textarea>
      </div>
    </aside>
  </div>

  <script>
    // Simple demo: Draw a grid on the canvas to show scrolling
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const canvasContainer = document.querySelector('.canvas-container');
    const scrollPosInput = document.getElementById('scroll-pos');
    const mousePosInput = document.getElementById('mouse-pos');

    // Draw a grid pattern to visualize scrolling
    function drawGrid() {
      const gridSize = 64;

      // Clear canvas
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid lines
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;

      // Vertical lines
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      // Horizontal lines
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw coordinate labels
      ctx.fillStyle = '#999';
      ctx.font = '12px monospace';
      for (let x = 0; x <= canvas.width; x += gridSize * 4) {
        for (let y = 0; y <= canvas.height; y += gridSize * 4) {
          ctx.fillText(`${x},${y}`, x + 4, y + 16);
        }
      }

      // Draw canvas bounds
      ctx.strokeStyle = '#f00';
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);

      // Draw center crosshair
      ctx.strokeStyle = '#00f';
      ctx.lineWidth = 2;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      ctx.beginPath();
      ctx.moveTo(centerX - 20, centerY);
      ctx.lineTo(centerX + 20, centerY);
      ctx.moveTo(centerX, centerY - 20);
      ctx.lineTo(centerX, centerY + 20);
      ctx.stroke();

      ctx.fillStyle = '#00f';
      ctx.fillText(`Center: ${centerX},${centerY}`, centerX + 25, centerY);
    }

    drawGrid();

    // Update scroll position display
    canvasContainer.addEventListener('scroll', () => {
      scrollPosInput.value = `${canvasContainer.scrollLeft}, ${canvasContainer.scrollTop}`;
    });

    // Track mouse position on canvas
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor(e.clientX - rect.left);
      const y = Math.floor(e.clientY - rect.top);
      mousePosInput.value = `${x}, ${y}`;
    });

    canvas.addEventListener('mouseleave', () => {
      mousePosInput.value = '-';
    });

    // Draw a sample object when clicking
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Draw a circle at click position
      ctx.fillStyle = '#f00';
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();

      // Draw label
      ctx.fillStyle = '#000';
      ctx.font = '12px monospace';
      ctx.fillText(`Click: ${Math.floor(x)},${Math.floor(y)}`, x + 15, y);
    });
  </script>
</body>
</html>
